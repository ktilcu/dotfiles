set background=dark
set hidden                                                   " hides buffers instead of closing them
set hlsearch                                                 " highlight search terms
set history=1000                                             " remember more commands and search history
set nobackup
set noswapfile
set nowrap                                                   " don't wrap lines
set pastetoggle=<F2>                                         " turn autoindent off to paste large amounts of text
set showmatch                                                " set show matching parenthesis
set shiftround                                               " use multiple of shiftwidth when indenting with '<' and '>'
set shiftwidth=4                                             " number of spaces to use for autoindenting
set smarttab                                                 " insert tabs on the start of a line according to shiftwidth, not tabstop
set tabstop=4                                                " actual tabs occupy 8 characters
set undolevels=1000                                          " use many muchos levels of undo

let g:rehash256 = 1
let g:molokai_original = 1

" keyboard shortcuts
inoremap jj <ESC>

" File type specific settings
autocmd BufRead,BufNewFile *.md set wrap
autocmd BufRead,BufNewFile *.md set textwidth=79
autocmd BufRead,BufNewFile *.md set formatoptions=qrn1
autocmd BufRead,BufNewFile *.md set colorcolumn=85

" Close buffers
nmap <leader>w :bd<CR>
" highlight search
"set hlsearch
"nmap <leader>hl :let @/ = ""<CR>

" clears the search buffer when you press ,/
nmap <silent> ,/ :nohlsearch<CR>

" View diff before saving
nnoremap <leader>D :DiffSaved<cr>

function! s:DiffWithSaved()
    let filetype=&ft
    diffthis
    vnew | r # | normal! 1Gdd
    diffthis
    exe "setlocal bt=nofile bh=wipe nobl noswf ro ft=" . filetype
endfunction
com! DiffSaved call s:DiffWithSaved()

" gui settings
if (&t_Co == 256 || has('gui_running'))
  if ($TERM_PROGRAM == 'iTerm.app')
    colorscheme monokai
  else
    colorscheme desert
  endif
endif

" Adding Functionality for closing buffers with <c-@> from ctrl-p
let g:ctrlp_buffer_func = { 'enter': 'CtrlPMappings' }
 
function! CtrlPMappings()
  nnoremap <buffer> <silent> <C-@> :call <sid>DeleteBuffer()<cr>
endfunction
 
function! s:DeleteBuffer()
  let path = fnamemodify(getline('.')[2:], ':p')
  let bufn = matchstr(path, '\v\d+\ze\*No Name')
  exec "bd" bufn ==# "" ? path : bufn
  exec "norm \<F5>"
endfunction

" UltiSnips completion function that tries to expand a snippet. If there's no
" snippet for expanding, it checks for completion window and if it's
" shown, selects first element. If there's no completion window it tries to
" jump to next placeholder. If there's no placeholder it just returns TAB key 
function! g:UltiSnips_Complete()
    call UltiSnips#ExpandSnippet()
    if g:ulti_expand_res == 0
        if pumvisible()
            return "\<C-n>"
        else
            call UltiSnips#JumpForwards()
            if g:ulti_jump_forwards_res == 0
               return "\<TAB>"
            endif
        endif
    endif
    return ""
endfunction

" Disambiguate ,a & ,t from the Align plugin, making them fast again.
" This section is here to prevent AlignMaps from adding a bunch of mappings
" that interfere with the very-common ,a and ,t mappings. This will get run
" at every startup to remove the AlignMaps for the *next* vim startup.
"
" If you do want the AlignMaps mappings, remove this section, remove
" ~/.vim/bundle/Align, and re-run rake in maximum-awesome.
function! s:RemoveConflictingAlignMaps()
  if exists("g:loaded_AlignMapsPlugin")
    AlignMapsClean
  endif
endfunction
command! -nargs=0 RemoveConflictingAlignMaps call s:RemoveConflictingAlignMaps()
silent! autocmd VimEnter * RemoveConflictingAlignMaps

au BufEnter * exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr>"
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
